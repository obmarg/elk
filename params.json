{"name":"Elk","tagline":"An elixir app for running google app engine pull queues.","body":"# Elk\r\n\r\nAn elixir application for running google app engine pull queues.\r\n\r\nThe actual tasks are implemented by python workers on a WSGI interface.  This\r\nallows the workers to be implemented in a similar fashion to GAE push queues.\r\n\r\n## What problem does it solve?\r\n\r\n### The Problem\r\n\r\nWhen building a python application on google app engine, you are somewhat\r\nlimited in the libraries and services you can use directly.\r\n\r\nIt's possible to work around this using HTTPS and the urlfetch service to make\r\nrequests to remote machines, but:\r\n\r\n* This isn't really suitable for long running requests, due to app engines\r\n  deadlines.\r\n* This brings with it extra security concerns (setting up and managing HTTPS\r\n  and authentication between the various endpoints etc.).\r\n* The urlfetch service is not always reliable.\r\n\r\n### A Possible Solution\r\n\r\nThe first problem could be solved by building a queue external to app engine\r\nthat deals with tasks as they come in.\r\n\r\nHowever, we could just use app engine pull queues to save us some of that work.\r\nThis also reduces the issue of security, as you don't have to expose any ports\r\non your external services.  App Engine just needs to feed tasks into the pull\r\nqueue, and the external service just needs to process them from the pull queue.\r\n\r\nWe may still need to deal with authentication when sending results back into\r\napp engine, but this should be easier than setting it up at both ends.\r\n\r\n### How does Elk help?\r\n\r\nElk aims to provide a simple server that can be deployed to one or many\r\nmachines, and will process tasks on a task queue.\r\n\r\nIt wouldn't be too hard to write a simple worker in python in a few lines of\r\ncode, but Elk aims to cut down on the need for boilerplate;  Allowing\r\ndevelopers to worry about implementing the task itself, not managing the task\r\nqueue.\r\n\r\nIt also tries to cover any edge cases that a naive worker implementation might\r\nmiss, and allows tasks to be written in a similar manner to appengine push\r\nqueues - as routes in a web application.\r\n\r\n#### Features\r\n\r\n* Handles OAuth authentication.\r\n* Handles task retries.\r\n* Ensures release/delete of task leases.\r\n* Exposes tasks as routes in webapp.\r\n* Batches requests for leases in quiet periods\r\n\r\n## Configuration\r\n\r\nElk is currently configured through environment variables:\r\n\r\nRequired Variables:\r\n\r\n* `ELK_PROJECT` - The app engine project to read queues from.\r\n* `ELK_TASK_QUEUE` - The name of the pull queue to read from.\r\n* `ELK_CLIENT_ID` - The client ID to read from the pull queue with.\r\n* `ELK_KEYFILE` - Path to our clients private key file.\r\n* `ELK_APP_PACKAGE` - The name of the python package to load the WSGI app from.\r\n* `ELK_APP_NAME` - The name of the WSGI app variable in ELK_APP_PACKAGE.\r\n* `ELK_VIRTUAL_ENV` - The path to the root of the virtualenv to use.\r\n\r\nOptional Variables:\r\n\r\n* `ELK_MAX_RETRIES` - The maximum number of retries for each task.\r\n\r\n## Instructions\r\n\r\nElk uses WSGI to run python tasks.  This means that we can expose tasks as\r\n\"routes\" in a web application, similar to how appengine push queue tasks are\r\ndefined.\r\n\r\nThere is an example application in the `example` folder that contains a python\r\nfile and a shell script for setting up environment variables.  This would be a\r\ngood place to start for developing a python task application.\r\n\r\n#### Configuring Elk\r\n\r\nSince elk is configured through environment variables, a configuration shell\r\nscript is the recommended way to configure an Elk deployment.  Ideally this\r\nscript should setup all the environment variables correctly, then start Elk\r\nitself.  `example/env.sh` makes a good starting point for this.\r\n\r\n#### Installing Elk Python Dependencies.\r\n\r\nElk comes with most of it's dependencies.  However, some dependencies need\r\ncompiled, and are not suitable for distribution with Elk.  These will need to\r\nbe installed manually, using `pip` or another package manager:\r\n\r\n* PyOpenSSL (On debian, this will require libffi-dev & python-dev to compile)\r\n\r\n#### Running Elk\r\n\r\nThese are the initial instructions for running elk.  Currently this involves\r\ndownloading and building from source. At some point I hope to release packages\r\nbut I've not figured out how to do that yet.\r\n\r\n##### Erlang Setup\r\n\r\nElk depends on erlang, which will need to be installed on the systems it is\r\nto run on.\r\n[Instructions can be found here](https://www.erlang-solutions.com/downloads/download-erlang-otp).\r\n\r\n##### Elixir Setup\r\n\r\nElk is written in Elixir (0.12.5) which will need to be installed.\r\n[Instructions can be found here](http://elixir-lang.org/getting_started/1.html)\r\n\r\n##### Other Requirements\r\n\r\nElk requires a recent version of pip to be installed in order to install it's\r\npython dependencies.\r\n\r\n##### Building Elk\r\n\r\nFrom within the elk directory:\r\n\r\n```shell\r\n$ mix deps.get\r\n$ mix deps.compile\r\n$ mix compile\r\n$ mix deps.python\r\n```\r\n\r\n##### Running Elk\r\n\r\nThe recommended way to run applications in Elk is using a virtualenv.  This\r\nvirtualenv should have all the applications dependencies, and the application\r\nitself installed within.  Applications with setup.py could be installed by\r\nrunning `setup.py install` or `setup.py develop` within the virtualenv.  For\r\nexample:\r\n\r\n```shell\r\n$ pip install virtualenv\r\n$ virtualenv venv\r\n$ venv/bin/pip install PyOpenSSL\r\n$ venv/bin/python setup.py\r\n```\r\n\r\nOnce the virtualenv has been setup, elk should be configured using environment\r\nvariables.  The recommended way to do this is to take `examples/env.sh`, copy\r\nit to the root of the source tree, and customise it with your settings. Don't\r\nforget to configure `ELK_VIRTUAL_ENV` to the root path of the virtual env you\r\ncreated.\r\n\r\nElk can then be run in the console like so:\r\n\r\n```shell\r\n$ . ~/env.sh\r\n$ iex -S mix\r\n```\r\n\r\nThis command should be run in the root of the elk source tree.\r\n\r\n#### Sending Tasks To Elk\r\n\r\nThe following code should add a task to a \"pulltest\" queue on app engine.  If\r\nused with the example application this would run it's root task, which simply\r\nprints to the logs.\r\n\r\n```python\r\n# The url is required to allow Elk to route to the correct task.\r\n# In this case we're just sending to the root URL.\r\npayload = {'url': '/'}\r\n\r\n# We should also send in a payload - this is the data that will actually be\r\n# sent in to the task routes themselves.\r\npayload['payload'] = {}\r\n\r\nq = taskqueue.Queue(\"pulltest\")\r\nq.add([taskqueue.Task(payload=json.dumps(payload), method='PULL')])\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}