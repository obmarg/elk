{"name":"Elk","tagline":"An elixir app for running google app engine pull queues.","body":"# Elk\r\n\r\nElk allows google app engine applications to easily run background tasks on\r\nexternal servers.  It is written in [Elixir](http://elixir-lang.org/), and uses\r\n[google app engine pull queues](https://developers.google.com/appengine/docs/python/taskqueue/overview-pull#Python_Pull_queue_overview).\r\n\r\nThe tasks themselves can be implemented in python.  Elk communicates to them\r\nusing WSGI, so they can be written as normal routes in a web application using\r\none of the many python web-frameworks.  Just like normal app engine tasks.\r\n\r\n## What problem does it solve?\r\n\r\n### The Problem\r\n\r\nWhen building a python application on google app engine, you are somewhat\r\nlimited in the libraries and services you can use directly.\r\n\r\nIt's possible to work around this using HTTPS and the urlfetch service to make\r\nrequests to remote machines, but:\r\n\r\n* This isn't really suitable for long running requests, due to app engines\r\n  deadlines.\r\n* This brings with it extra security concerns (setting up and managing HTTPS\r\n  and authentication between the various endpoints etc.).\r\n* The urlfetch service is not always reliable.\r\n\r\n### A Possible Solution\r\n\r\nThe first problem could be solved by building a queue external to app engine\r\nthat deals with tasks as they come in.\r\n\r\nHowever, using app engine pull queues can save some of that work. It can also\r\nease some of the security pains, as you don't have to expose any ports on your\r\nexternal services.  App Engine just needs to feed tasks into the pull queue,\r\nand the external service just needs to process them from the pull queue.\r\n\r\nApp Engine provides a REST API for pull queues with OAuth authentication over\r\nHTTPS, which saves you implementing something similar yourself.\r\n\r\nYou may still need to implement some authentication when sending results back\r\ninto app engine, but this should be easier than setting it up at both ends.\r\n\r\n### How does Elk help?\r\n\r\nElk aims to provide a simple server that can be deployed to one or many\r\nmachines, and will process tasks on a task queue.\r\n\r\nIt wouldn't be too hard to write a simple worker in python in a few lines of\r\ncode, but Elk aims to cut down on the need for boilerplate;  Allowing\r\ndevelopers to worry about implementing the task itself, not managing the task\r\nqueue.\r\n\r\nIt also tries to cover any edge cases that a naive worker implementation might\r\nmiss, and allows tasks to be written in a similar manner to appengine push\r\nqueues - as routes in a web application.\r\n\r\n#### Features\r\n\r\n* Handles OAuth authentication.\r\n* Handles task retries.\r\n* Ensures release/delete of task leases.\r\n* Exposes tasks as routes in webapp.\r\n* Batches requests for leases in quiet periods\r\n* Decouples workers from task queue, they can be debugged as a web-app\r\n  normally.\r\n\r\n## Configuration\r\n\r\nElk is currently configured through environment variables:\r\n\r\nRequired Variables:\r\n\r\n* `ELK_PROJECT` - The app engine project to read queues from.\r\n* `ELK_TASK_QUEUE` - The name of the pull queue to read from.\r\n* `ELK_CLIENT_ID` - The client ID to read from the pull queue with.\r\n* `ELK_KEYFILE` - Path to our clients private key file.\r\n* `ELK_APP_PACKAGE` - The name of the python package to load the WSGI app from.\r\n* `ELK_APP_NAME` - The name of the WSGI app variable in ELK_APP_PACKAGE.\r\n* `ELK_VIRTUAL_ENV` - The path to the root of the virtualenv to use.\r\n\r\nOptional Variables:\r\n\r\n* `ELK_MAX_RETRIES` - The maximum number of retries for each task.\r\n\r\n## Using Elk\r\n\r\nElk uses WSGI to run python tasks.  This means that we can expose tasks as\r\n\"routes\" in a web application, similar to how appengine push queue tasks are\r\ndefined.\r\n\r\nThere are 2 example applications in the `example` folder:\r\n\r\n* The `docker` example contains a python application and a Dockerfile for\r\n  building a docker image for the application.  This is the recommended method\r\n  for deploying Elk at the moment, as it avoids the need for compiling Elk.\r\n* The `basic` example contains a python application and a shell script for\r\n  setting up environment variables.  This would be a good place to start for\r\n  developing python task application.\r\n\r\n#### App Engine Setup\r\n\r\nYou will need to setup a pull queue on google app engine, using the queue.yaml\r\nfile.  [Instructions on configuring a queue are here](https://developers.google.com/appengine/docs/python/config/queue#Python_Defining_pull_queues).\r\n\r\nYou will also need to setup a google service account for Elk to use to read the\r\ntask queue REST API.  This can be done under \"APIs and Auth\" - \"Credentials\" in [the google cloud console](https://console.developers.google.com/project).  You will need the email address of the user, and the users secret key to configure elk.\r\n\r\nBe sure to list this service account under the `user_email` section for your\r\nqueue in your queue.yaml file.\r\n\r\n#### Configuring Elk\r\n\r\nElk is configured through environment variables.  Using the recommended docker\r\ndeployment, these can be configured in the Dockerfile using the `ENV` command.\r\nAn example of such a Dockerfile can be found in `example/docker/Dockerfile`.\r\n\r\nAlternatively, an env.sh script can be used. Ideally this script should setup\r\nall the environment variables correctly, then start Elk itself.\r\n`example/basic/env.sh` makes a good starting point for this.\r\n\r\n#### Running Elk\r\n\r\n##### Using Docker (recommended)\r\n\r\nElk provides a base Dockerfile in `docker/`.  You can create a Dockerfile for\r\nyour application using this as a Base.  There is an example of this in the\r\n`examples` folder.  You should just need to set the `CMD` of your docker image\r\nto `elk console` .  This should allow you to run Elk using `docker run\r\n<image-name>`\r\n\r\n##### Using an Elk Release (currently not very well supported)\r\n\r\nIf you are using an Elk release, then you should run `elk console` with the\r\nappropriate environment variables set.  You must ensure that PyOpenSSL is\r\nincluded in the release, or otherwise accessible to Elk.\r\n\r\n##### Running Elk from Repository\r\n\r\nOtherwise, running `iex -S mix` from within the Elk repository should do the\r\ntrick.  You will have to build Elk before doing this, by following the\r\ninstructions below.  More details on running Elk manually can be found under\r\n\"Running Elk Manually\" below.\r\n\r\n#### Sending Tasks To Elk\r\n\r\nThe following code should add a task to a \"pulltest\" queue on app engine.  If\r\nused with the example application this would run it's root task, which simply\r\nprints to the logs.\r\n\r\n```python\r\n# The url is required to allow Elk to route to the correct task.\r\n# In this case we're just sending to the root URL.\r\npayload = {'url': '/'}\r\n\r\n# We should also send in a payload - this is the data that will actually be\r\n# sent in to the task routes themselves.\r\npayload['payload'] = {}\r\n\r\nq = taskqueue.Queue(\"pulltest\")\r\nq.add([taskqueue.Task(payload=json.dumps(payload), method='PULL')])\r\n```\r\n\r\n#### Developing Elk Workers\r\n\r\nSince Elk interfaces with it's workers using WSGI, they can be developed and\r\ntested as if they were a website - you can make use of the development servers\r\nand interactive debuggers present in most python web-frameworks.\r\n\r\nTODO: Add more details\r\n\r\n## Building Elk\r\n\r\n#### Installing Elk Python Dependencies.\r\n\r\nElk comes with most of it's dependencies.  However, some dependencies need\r\ncompiled, and are not suitable for distribution with Elk.  These will need to\r\nbe installed manually, using `pip` or another package manager:\r\n\r\n* PyOpenSSL (On debian, this will require libffi-dev & python-dev to compile)\r\n\r\nIt's fine to install this globally, or in the virtualenv Elk will be using.\r\n\r\n##### Elixir Setup\r\n\r\nElk is written in Elixir (0.12.5) which will need to be installed.\r\n\r\nFor Mac OS, this can be done with\r\n    \r\n    homebrew install elixir\r\n\r\nWhich will install Erlang, and Elixir. Otherwise [Instructions can be found\r\nhere](http://elixir-lang.org/getting_started/1.html)\r\n\r\nElixir depends on erlang, which will need to be installed on the systems it is\r\nto run on. [Instructions can be found\r\nhere](https://www.erlang-solutions.com/downloads/download-erlang-otp).\r\n\r\n##### Other Requirements\r\n\r\nElk requires a recent version of pip to be installed in order to install it's\r\npython dependencies.\r\n\r\n##### Building Elk\r\n\r\nFrom within the elk directory:\r\n\r\n```shell\r\n$ mix deps.get\r\n$ mix deps.compile\r\n$ mix compile\r\n$ mix deps.python\r\n```\r\n\r\n##### Running Elk Manually\r\n\r\nThe recommended way to develop applications for Elk is using a virtualenv.\r\nThis virtualenv should have all the applications dependencies, and the\r\napplication itself installed within.  Applications with setup.py could be\r\ninstalled by running `setup.py install` or `setup.py develop` within the\r\nvirtualenv.  For example:\r\n\r\n```shell\r\n$ pip install virtualenv\r\n$ virtualenv venv\r\n$ venv/bin/pip install PyOpenSSL\r\n$ venv/bin/python setup.py\r\n```\r\n\r\nOnce the virtualenv has been setup, elk should be configured using environment\r\nvariables.  The recommended way to do this is to take `examples/env.sh`, copy\r\nit to the root of the source tree, and customise it with your settings. Don't\r\nforget to configure `ELK_VIRTUAL_ENV` to the root path of the virtual env you\r\ncreated.\r\n\r\nElk can then be run in the console like so:\r\n\r\n```shell\r\n$ . ~/env.sh\r\n$ iex -S mix\r\n```\r\n\r\nThis command should be run in the root of the elk source tree.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}